// ⠜⡀⣾⣿⣿⣿⣶⡀⠹⡀⡄⡇⡆⡀⠸⡀⡀⡀⣠⠎⠐⠘⢀⠇⡤⡀⢁⠈⢷⣿⠟⡇⡀⢁⠛⡱⢸⡀⠰⣨⠁⠚⠃⠓⣌⠂⢟⡀⡇⠢⠄⡀⠸⠸⠸⡀⠷⠘⡌⡀⠧⠳⠑⠙⠑⠂⡀⠃⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡐⣸⣿⣿⡿⣿⣿⣿⡀⣷⣻⣷⡗⡃⡂⠠⡀⣴⠁⣀⠁⣮⠗⠞⣆⡀⡡⡈⠡⠙⡀⢿⢄⠄⠿⡀⠄⠳⡀⡀⢄⠚⠉⠙⡆⡀⢹⡀⣯⡄⠉⣄⡀⣴⢀⠋⠙⡙⢈⠈⣱⡌⠯⠛⡀⠠⡀⠈⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⣇⢹⣿⣿⣷⡀⢀⡀⡀⢿⢻⢯⡇⣇⡁⠁⣴⠁⣠⣥⠴⡴⢟⢋⣷⡈⣠⡈⣡⢷⡈⢾⠆⠁⠖⡀⣠⡀⢀⡀⣇⢠⠉⠓⡙⡀⡀⣆⠸⡂⣴⠉⢀⠁⣥⠛⠴⠃⣛⠓⠋⠓⠬⢁⠶⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡻⠈⣿⣿⣿⣿⡀⢈⡆⢷⣸⢸⡧⡽⡟⡖⠏⢴⣅⣿⢸⢴⣧⡀⡿⠉⣀⠧⠾⣼⠁⡏⢈⡴⠛⠁⠖⢛⡀⡄⢈⠄⠑⡀⠙⠷⡄⠈⠲⣠⠒⠶⠋⣴⠁⣾⠃⠘⠐⠙⠥⡈⢴⠠⡩⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⣻⣮⡄⠉⠉⡀⣀⡹⡁⣽⣏⠈⡇⡝⣿⡀⡀⡀⠙⣿⣸⡿⠲⣬⢧⣙⢦⠙⡜⡠⣡⠞⣃⢌⡙⡀⢃⣀⣠⡽⠒⢉⣉⣁⡁⠁⣀⠄⡐⠈⠌⡀⣠⣏⠇⣀⣴⣾⣿⠿⢿⣤⠛⢧⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠾⣥⣌⣋⣛⣉⣋⣤⣾⡧⢷⢳⣻⢡⠁⣠⠶⠊⠁⡀⠻⣷⠋⣾⠐⣤⡑⢩⢋⣞⢰⡱⢂⡄⣠⠹⢀⠤⡀⠴⠋⣀⡀⠚⡀⢀⣀⣀⣀⡉⡀⠷⡀⡄⡀⣿⣛⣀⣔⣮⢿⠾⠿⡶⣤⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠙⠛⠓⠒⠲⠒⠒⣒⠛⢛⠛⡛⢿⠟⢈⡀⡀⡴⠋⠉⠉⠋⣯⠚⣉⠓⣠⢣⠛⢠⡝⠃⣈⣄⠋⡔⣤⠂⣾⠐⢁⣴⠿⠻⠛⢉⣤⢶⡶⣿⣷⣄⠙⡄⢸⢭⡿⠿⣶⣶⣶⣶⣶⣶⣒⠒⠤⣀⠈⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠙⠪⠣⠊⣖⡀⢐⢀⠑⢶⢦⠻⣿⠬⣿⠙⢰⠈⡈⡀⡀⠚⢺⢿⡶⣽⢩⣷⣤⠃⡼⡉⡴⢀⢠⡾⣇⠈⣠⣾⡟⡔⣤⡶⢛⠃⢀⣠⣿⡟⠛⠛⣷⣀⡜⡀⠄⠉⠪⢙⢿⣿⣿⡿⢶⣟⠿⣤⠠⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠁⡀⡀⡐⡀⠡⡀⢈⠴⠴⣤⣱⣿⢻⣿⢻⡸⡹⢻⣌⡖⠻⣷⡿⡾⣱⣹⠹⠆⣶⢳⠋⣴⣉⢸⡔⣠⣾⣱⣿⣿⡿⡰⣠⡏⢀⢳⠙⡀⡀⡀⡀⡀⠈⡀⡀⡀⡀⡀⡀⠐⣝⣿⣿⣿⣷⣮⠶⢳⠡⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⠑⠭⡀⡀⡈⠠⠠⢀⣤⠶⣶⣦⣿⣿⡳⣳⡏⣿⣿⣛⣟⡟⣾⢟⣤⣣⣿⠞⡵⢩⢦⠉⣡⣿⣿⣼⣿⣿⣿⢣⣾⠋⠅⡞⡿⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⡀⠑⣿⣿⣿⣿⣿⣌⡆⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⠸⡀⡀⣰⢀⡡⡝⣤⣄⢿⣽⠿⣯⣮⣷⣶⣶⣾⣾⢾⣬⣤⡤⣶⠏⡼⣱⣷⣿⣿⠃⣎⢿⣿⣿⣷⣿⢃⢰⢡⠇⡇⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠁⡀⢿⣿⣮⢿⣿⣝⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⢢⡀⠡⡀⡀⣇⠈⡇⢷⠛⠛⣨⠿⣻⣿⣿⣿⣿⣿⣿⣿⠿⠿⣿⡷⣿⡟⣼⣿⡿⣋⣴⣧⣿⣷⣈⠿⠿⡡⠃⣾⣿⣼⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣿⣝⢷⣈⠛⠶⠠⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⢱⡀⡸⠣⠹⡀⠙⣗⠙⣻⢀⠟⠠⣤⣶⣿⣿⡷⣧⢾⣙⣿⣧⣿⣿⣿⣿⣿⣿⣿⣿⣿⣌⣿⢻⣷⣶⠾⣫⠞⡵⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣿⣷⣬⣉⡛⠒⣒⣢⢠⡐⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⠁⢙⢌⡲⣡⢉⠳⢤⣤⠶⡿⣩⣿⢉⠏⣿⣿⢿⡤⣟⣟⣷⣾⣿⣿⢿⣿⣟⣿⡿⣻⣾⣿⣷⣭⣭⣭⡭⠖⠉⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣤⣾⡿⠻⠓⢹⣿⡽⡘⡹⣿⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⠐⣠⠃⡮⠓⢬⣝⣛⣩⡿⡄⣐⣄⡄⣦⡟⡜⣦⣿⣯⣟⣿⣟⣾⣿⣶⣿⣿⣿⣿⣿⣿⣿⣿⡟⡐⡀⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠂⠔⡀⡀⢀⣿⡿⢣⡪⢘⡀⡀⣿⣿⣕⡀⠪⠨⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⠁⡀⠠⡀⡇⠸⠠⢨⡌⢱⠙⣌⠴⠋⠯⡎⣈⡤⠋⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⢿⣿⣫⣿⢫⡟⠠⡀⡀⡀⡀⣀⣠⣤⣶⣶⣶⣶⣦⣄⡀⡀⡀⡀⡀⡀⡀⣿⡹⣮⡿⠟⠿⡦⡀⣿⣿⣿⣶⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⠂⢢⠓⠢⢵⠈⣄⢐⡶⠺⢰⣛⠟⡴⣦⣼⢋⢼⣿⣿⠿⠿⣿⣿⣿⣭⡾⢋⣶⢟⣴⢋⢈⡀⣠⣶⣿⠿⠿⡻⢿⣻⣻⣿⣿⣿⣻⢯⢂⡀⡀⡀⡀⣸⢡⣿⠁⡀⢀⣤⣶⣤⣿⣿⣷⢙⡚⠤⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⠈⡀⡀⡀⢀⡀⡈⡉⠛⠶⠟⢀⢾⠉⠎⣿⣿⣿⣿⣯⣛⠶⠶⢶⣿⣿⣿⣿⢱⠇⣰⡿⠛⠁⢀⡔⢂⣩⣵⣿⣿⣿⣿⣿⣿⣿⡞⠨⡀⡀⡀⠎⣿⡋⣤⡿⠇⣿⠛⡄⢿⣿⣿⡔⡀⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠁⢀⠳⠶⠒⣼⠲⠎⢭⣺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡯⣿⣤⣾⠋⡠⠔⢇⣱⣿⠋⠁⡀⡀⠈⢻⣿⣿⣿⣯⡩⠕⡁⡀⡀⡀⣯⣿⡉⡀⡀⣀⣡⡆⠘⣿⣿⣯⢆⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⠂⡀⡀⣢⠾⣻⠗⣲⣷⣿⣿⣿⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡟⢴⣺⣷⣯⣾⣟⡄⡀⣠⣶⣿⣿⣿⣿⣉⡀⠊⠑⠈⡀⡀⡀⡀⡀⡀⡀⠉⠋⠫⠋⡀⡀⢿⠿⡇⠇⢸⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⡀⠸⡛⠰⣨⡾⣸⣿⢻⠟⢶⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣾⣿⣿⣿⣿⣿⣿⣿⢏⠄⠫⠿⣸⢘⠋⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣮⠰⢎⡑⠈⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢢⠙⠶⣌⣉⣋⣉⣉⣀⣤⣾⡿⣟⣻⣾⣿⣿⣿⣿⣿⣿⡗⡪⢿⣿⣿⣿⣿⣿⣿⣿⣏⢅⣀⣀⣡⡶⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠸⢧⣑⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠙⢶⣶⣶⣪⣿⢽⠛⣥⣿⣿⠿⣻⣷⣿⣿⣿⣿⣿⣿⢸⣂⡀⡀⡀⡀⠈⠙⠻⡟⡻⡟⡋⠁⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠑⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡢⡀⠈⠒⣸⠿⡼⠂⣿⡿⣭⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡱⢪⠅⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠦⣉⣉⡴⠛⣤⣿⣟⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⡁⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⣀⣀⣀⣀⡄⡄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⠒⠶⠚⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢧⡸⠡⢄⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣆⢣⣶⣶⣶⣀⣨⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⡀⢟⡝⢼⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡺⢪⡍⠡⠡⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠉⠁⠹⣿⣿⣿⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠌⡎⢼⠾⣿⣿⣿⣿⣿⣿⣿⣿⣿⡹⣿⣿⣟⡇⢪⡅⢐⡂⡀⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣀⠙⠉⣴⠆⣀⡅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠁⣿⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡗⡟⢯⣎⣕⡪⢅⢢⡨⠠⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡴⢫⣜⣁⣬⣶⠋⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢠⡀⣼⡀⣿⣿⣿⣿⣝⡻⣿⣮⣎⢢⡮⠕⢪⡣⡆⢜⡣⢎⢅⡡⡀⡀⠠⡀⠂⡀⡀⡀⡀⡀⡀⡀⡀⢀⣶⣶⣷⠟⠋⠉⠉⠉⡀⡜⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⠚⠁⠜⣿⣿⣿⣿⣿⣷⣑⣽⡀⡗⡑⢐⣾⡈⢑⢸⡕⠪⢕⡆⢅⡂⡀⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠑⡒⢊⣡⣌⣼⢁⡀⡀⡀⡀⠊⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣀⣯⣿⣿⣿⣿⣿⣿⣿⣄⠌⣴⠇⢠⣿⣷⡀⡐⠨⢘⡑⢑⡊⠡⠌⠡⠨⠂⠠⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠑⠫⠛⠙⠉⠅⠂⡀⡀⡀⡀⡀⢀⡀⡀⢄⠐⠲⢂⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣄⠂⢁⠑⢊⣽⣶⣿⣿⣿⣿⣿⣿⣿⠟⣿⡟⡧⠻⣿⣿⣿⣿⡄⠁⠐⠅⡊⡘⠱⠜⡢⢌⠌⡂⠨⠅⢐⠁⠠⡀⡀⡀⡀⡀⠐⡀⡀⡀⡀⡀⡀⡀⡀⣁⢆⢳⠈⣴⢨⡘⠨⡀⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠠⡀⠬⠛⠶⢮⡶⠿⠿⣯⣿⣿⣿⣿⣿⣡⠉⠁⡄⢨⡀⢻⣿⣿⣿⣿⣆⡀⠡⠄⠆⢎⢆⡨⢅⡌⠪⣊⢌⢌⡊⢌⠵⠆⠉⡀⡀⡀⡀⡀⢀⣤⢲⣳⣙⣸⣴⠿⠚⠈⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡈⠢⢀⣈⠉⣁⣦⣾⣿⣿⣿⣿⠿⠁⠉⡌⠻⣡⢨⠃⡗⣬⢿⣿⣿⢿⣯⣤⡀⡀⠈⠨⢱⡪⢕⡮⠗⠛⠉⡀⡀⠑⡀⡀⡀⡀⣄⣷⢸⡽⢾⣿⣯⠛⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠉⠳⣶⣶⡶⣿⣿⣿⣿⣿⡇⣇⡄⡄⢩⠙⣉⡘⠑⡇⣧⠳⣿⣿⡞⣹⣎⡻⣮⣴⠮⠚⠃⡀⠂⡀⠄⠒⠰⢀⡄⣷⡄⣇⣿⣧⡿⠿⠉⡀⡀⡀⢠⢡⠈⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠨⡀⠼⠃⣜⠪⡿⣿⣿⣿⡗⡴⠾⠘⣄⡀⣣⡠⡹⢰⡁⡏⣿⣿⡽⠾⢉⠉⡀⡀⢀⠰⡀⡠⡀⣉⣤⠞⣋⣵⠷⣻⠿⠙⡀⣀⣀⡠⠂⣈⣤⣞⢏⣁⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⢁⢀⠏⢸⢸⣿⣿⣿⣿⠐⠛⢈⠠⢍⣉⡤⣾⠟⠚⠘⠁⡀⡀⡀⡀⢢⢱⠘⣃⣥⡴⣛⣭⠶⢛⣭⣴⣾⣿⣿⣿⣿⣿⡟⠅⡀⡀⡏⣮⢮⢬⠠⡄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⢀⠃⢿⣿⣻⣿⣿⣷⣶⣈⢸⡀⠇⠁⡀⡀⡀⢀⡀⡀⣤⢮⣰⢾⣾⢛⠶⣛⣭⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⡺⢇⠁⡀⡀⠸⡘⢞⡸⢅⢐⠐⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⢣⠿⣵⣿⡿⠟⠋⠉⡀⡀⢀⡀⢆⣄⠜⣆⣄⣷⠿⢿⡿⠟⠺⢔⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣪⣕⢪⢀⡀⡀⡀⠻⣜⡳⡈⠔⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⠄⠠⠆⠑⠙⠉⠁⡀⡀⠐⡀⡀⢰⣠⢸⢺⣸⠘⠉⢉⡴⠛⠉⡀⢀⢁⢱⡎⢽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡽⡳⢎⡑⡀⡀⡀⡀⡀⡏⣷⣊⣕⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⠠⠠⠠⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡄⡒⣽⣾⣧⣿⡼⢋⣽⣿⣿⣿⡇⡀⡀⡀⠈⠢⢸⡣⢞⣺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⢮⢸⡇⢕⠂⡀⡀⡀⡀⡠⠢⠻⣴⠂⡀⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⠈⣢⢀⡀⡀⡀⡀⡂⡀⡀⢀⢀⢐⠐⣀⣴⡿⠿⣻⠿⠉⠵⠟⣿⣿⣿⣿⣿⣿⡇⡀⡀⡀⡀⢐⡐⢸⡯⣹⡯⣽⣟⣿⣿⣿⣿⣿⣿⣻⣻⢫⢪⢕⢨⠠⢄⠒⡀⠊⡤⣇⠆⣿⠲⣤⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⢀⡆⡀⡀⡀⠐⡀⣤⢷⢺⣚⠹⠉⠊⠈⡀⡀⡀⡀⠘⣸⡟⣿⣿⣿⣿⣿⡇⡀⡀⡀⡀⢈⠩⢕⡪⢝⣳⢿⣯⣻⣿⣯⣷⣿⣾⣾⡯⢕⢸⡕⣌⠜⡀⢠⢋⡀⠂⠙⡀⣿⢰⡗⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠻⡀⡀⡀⡀⡀⠈⣧⡀⡀⡀⡀⡆⠘⠃⡀⡀⡀⡀⡀⡀⡑⢒⡔⣖⣫⣽⡿⣫⣿⣿⣿⠛⠘⡀⡀⡀⡀⠌⢊⡸⢇⣪⡞⡳⢮⢝⢯⣻⣟⣯⡯⣳⡽⣹⠵⢊⠐⣠⠚⣠⡆⣇⡞⡜⡠⣾⢾⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⠻⡀⡀⡀⡀⡀⠸⡅⡀⡀⡀⠡⡀⡀⡀⡀⡀⡀⡀⡀⡀⠤⣌⣈⣍⣶⣿⢿⣿⣿⠇⢄⠁⠘⢦⡀⡀⠂⠐⡱⢪⡧⡕⣺⣝⣺⢿⢾⣻⣿⢾⢛⣩⠔⣡⠚⡥⠉⡄⡵⠦⡀⡴⣠⡷⣳⣹⡄⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⢻⡀⡀⡀⡀⡀⢻⠂⡀⡀⠐⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⡔⡌⠱⢹⣿⢹⡀⡂⠁⠈⠲⣌⡓⠦⣤⣤⡪⣝⣣⣸⣮⡿⠾⠟⠉⣋⣭⡔⡞⡥⢶⡘⡀⡟⣤⠖⢡⠊⣴⣯⠏⠉⡀⡀⡀⡀⡀⠐⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⡀⡀⡀⢻⡀⡀⡀⡀⡀⠂⡀⡀⡀⠠⡀⡀⡀⡀⡀⡀⡀⠠⡀⠄⡠⠔⡣⣴⡏⢸⠘⠰⠈⠄⠴⠙⢳⢀⠻⢚⡈⢿⢶⠶⢒⠶⠶⡛⣙⢃⡟⡄⠛⣧⡙⠶⣿⠟⣤⠧⠋⣤⢟⠟⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⢼⠠⠑⠈⡀⢀⠄⡀⡀⡀⡀
// ⡀⡀⡀⡀⢧⡀⡀⡀⡀⢀⡀⡀⡀⠈⡀⡀⡀⡀⡀⡀⡀⡀⣃⢌⢰⢊⣴⡟⡀⡀⢆⠣⠡⠻⠛⢸⡨⣾⣠⣧⠞⣡⢣⢣⣿⢮⣻⠙⠰⠱⠞⡃⢟⣓⡌⠛⣀⠟⣁⠶⢿⣸⠻⠃⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡆⣢⠽⠋⡀⡀⠠⠔⡀⡀
// ⡀⡀⡀⡀⡀⠁⡀⡀⡀⡀⢥⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⣏⣿⣿⡀⢀⠉⡀⡀⣄⠑⣀⠋⠳⣀⠆⣷⡽⠞⣁⣾⠎⠛⠹⠟⡇⡛⢁⣧⡸⠶⠅⠂⣥⡖⣹⢤⠖⠘⣿⡜⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢷⢕⣢⢵⠉⠁⡀⡀⡀⡀
// ⢭⡀⡀⡀⡀⡀⡀⡀⡀⢀⢕⡂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠁⣿⢿⣿⡀⣴⡀⠈⡄⢂⡝⢤⠙⠶⣤⣹⣀⣾⢘⡅⣼⣟⣭⡆⡏⣤⠇⠓⣀⣤⢒⡽⢉⠄⣈⠃⠶⣼⣠⢟⢿⠘⡀⡀⡀⢀⡀⡀⡀⡀⡀⡀⡀⡀⣾⡷⠃⡀⡀⠐⡀⡀⡀⡀
// ⡀⡀⡀⡀⡀⡀⡀⡀⡀⠠⢢⡄⢀⢐⡀⡀⡀⡀⡀⡀⡀⢠⡀⣿⢜⣯⡀⠟⡀⠌⠌⠧⡀⣵⢨⢳⢆⡠⠉⣉⡉⣉⣉⣉⣠⡤⠶⠶⠋⠡⠘⠉⡀⡨⠰⠙⡀⡏⣦⠲⢃⣊⠶⠽⠓⢮⢌⣠⡆⡀⠄⢀⠈⡀⣀⡀⣿⣨⠜⠊⡀⡀⡀⡠⠆⠐
// ⡀⡀⡀⡀⡀⡂⠡⡀⠂⠠⢎⡅⠁⡀⡀⡀⠈⢢⢄⠒⢄⢌⣰⢇⡟⣴⠋⡁⠂⡔⣀⠑⡁⠦⠸⠹⠘⢀⠁⡀⢡⣀⡆⡴⠋⡀⠐⠐⣘⡄⠴⠋⢁⡀⡐⠇⠡⠛⣴⠉⡀⡀⡀⡀⡀⡀⡀⡀⡿⠟⣶⠢⢄⢼⣣⣾⢚⠁⠠⠒⢑⠈⠁⡀⡀⡀
// ⢀⡀⡀⡀⡀⠐⠠⠁⠡⡢⠕⠁⠅⡀⡀⡀⡀⡀⡀⢧⢱⣴⣿⣻⢱⢀⡃⠄⢢⡇⠠⠑⣈⠂⡄⢫⠈⣠⠈⡌⠚⠞⡔⠶⠒⢚⠉⡀⡆⠆⠆⠂⣤⠂⢉⠟⢱⠋⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠑⣼⣷⣶⣿⢟⠂⢰⠳⠕⡀⡀⡀⡀⡀⢀⠠
// ⠈⡑⠁⡀⡀⡈⠂⡁⠡⠰⠱⠅⢐⡀⡀⡀⡀⡀⡀⡀⣿⣷⣙⢿⡺⠈⡜⣀⠤⣶⠈⠄⡶⠁⡇⣎⢘⣀⡴⢠⢠⡀⠧⠤⠃⠚⠈⠤⠐⢰⣄⠋⣼⣄⠈⡃⠁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣿⣿⠡⡁⣞⡎⡀⡀⡀⡀⠠⡨⠘⡀⢀
// ⡀⡀⠂⠈⠈⡀⠌⠅⠐⡑⡑⡂⠨⡀⡀⡀⡀⡀⡀⡀⣿⠆⢻⢸⡅⡞⡀⠔⠁⠚⡀⢁⡇⠁⠹⣤⣅⣡⣴⠋⢰⢈⡁⣆⢳⢰⠈⢆⡴⠏⡀⢱⡀⠆⣴⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣼⢠⢰⣿⠃⡀⡀⡠⢆⡴⠋⡀⠔⠉⡀
// ⡀⠂⡀⠂⡀⢀⠡⠢⡅⡢⠪⠨⠅⡀⡀⡀⡀⡀⡀⡀⣼⠃⢙⠈⡇⡀⠄⠚⣁⠎⢠⢧⢘⢀⣠⠿⠋⠠⡀⠌⣸⡀⡄⠆⡀⡆⢶⠁⠙⣤⠎⡀⡆⢠⢆⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⣾⢧⣴⡿⡀⡀⡠⢹⠞⡀⠤⡙⢀⡀⠐⡀
// ⡀⡀⢀⠅⠂⢐⡂⠔⢑⡑⢂⡁⠂⡀⡀⡀⠄⠠⡀⡰⢿⡶⠉⡇⢷⡀⢀⡴⢁⠂⠣⢀⠁⡜⠂⢹⢋⠈⡐⢸⢰⠘⡼⢟⠛⡄⠳⡀⡀⡀⣆⠏⡴⢁⢿⠄⡁⠄⡀⢄⡀⡀⡀⡀⡀⢀⡀⡀⠜⢈⣸⣳⠟⡀⢀⡾⠎⡀⣴⠌⠠⡀⣠⠂⠄⣀
// ⢈⡀⠠⠈⠂⠨⢕⠬⠣⡸⠎⠁⡀⠰⠂⡮⠁⠢⡅⣾⣉⡇⣃⢿⠘⡌⠉⠄⡡⠈⠁⣡⢻⠜⡀⢠⠁⡇⡇⢨⡌⢰⡀⡀⢤⢈⠆⡀⢐⠴⣡⠛⡄⡟⣮⠽⠙⡌⢿⡄⣸⠶⠉⡑⠂⠄⢑⡩⢠⡏⣽⠋⡀⣴⡏⠌⣠⠟⡜⣤⠡⠑⢠⠡⠁⠁
// ⢐⡀⠁⠡⠢⠪⡪⠣⠜⢪⠅⠂⡀⠁⠐⣼⢻⠇⣽⣿⢀⡿⡉⣄⢷⠙⡄⢀⠁⠇⣃⡀⡀⡆⠆⡆⡸⢹⠈⡀⡺⣾⡀⡀⡀⠄⢀⡔⢁⡞⢀⢳⡟⠠⢤⠖⠃⠙⠆⡿⠲⠾⠶⣤⠱⣬⣤⡫⣿⣿⠋⢠⠟⠃⣠⣺⠁⡀⠌⠴⣀⠈⠘⠈⡀⠁
// ⢈⠄⡀⡐⠅⡊⡊⠌⢘⡣⠄⡀⡀⡀⡀⡀⡀⠿⣿⣿⢐⠻⡸⡀⠟⣧⠘⣦⠸⡀⡄⠃⠐⠈⡀⡤⡥⡼⣰⢸⠃⠇⡀⡀⢸⠔⢁⡞⢆⢀⠎⠉⡀⡀⡀⡀⡀⡀⡀⡀⡀⠛⠶⡹⣾⢿⠰⣽⣿⠃⣰⠏⠎⣾⣫⢁⠄⠄⡇⠁⡤⢀⠃⡀⡀⡀
// ⡘⢕⠌⠣⢑⢇⢌⡌⠢⠄⠁⡀⡀⡀⡀⡀⡀⡀⢿⠋⣭⣳⣰⣄⣏⣯⢷⡐⣙⢻⣐⣉⢈⢋⣭⣲⣀⣃⣃⣟⠸⢀⣀⣈⣠⣛⣁⣀⣃⣍⣄⣺⡋⣆⣀⣀⣀⣀⣀⣀⣀⣀⣀⣿⣻⣿⣿⣿⠃⣴⠏⢂⣿⡵⢦⡤⡀⣀⡀⠨⡀⡀⡀⡀⡀⡀
// ⢌⡐⡑⠨⡣⡂⡑⡃⢰⡂⡀⡀⡀⡀⡀⡀⡀⡀⠈⡀⠩⠁⡀⠃⠋⠼⡀⠉⢛⢸⢩⢸⣈⢸⢩⢸⠸⢸⢩⢼⣼⡬⠛⡛⡿⣛⠸⢸⢩⢿⢸⢸⣛⣿⣽⡏⢽⢂⡀⠇⣃⠇⡟⡥⣧⡿⣿⡏⣴⠏⣀⣿⣱⠱⠈⠶⠉⠤⠘⡀⡀⡀⡀⡀⡀⡀
// ⢸⢕⠱⠆⠢⡌⡔⡸⢎⠂⡀⡀⡀⡀⡀⢄⡀⡀⢀⣲⢩⠒⡀⣷⣙⠧⣖⢹⣤⢾⠉⣾⢀⢺⠍⠚⣠⡖⠿⠦⢫⡙⠙⢓⢃⡖⡟⢚⡟⠼⠚⡀⠘⠃⠙⠋⡀⠓⠒⡀⡀⠓⠋⠛⣿⣿⣿⣇⡿⢠⣿⡗⣿⡔⠇⡲⠈⠐⡀⡀⡀⡀⡀⡀⡀⡀
// ⡱⢆⡊⢌⢌⡌⡑⡀⡀⡀⡀⡀⠴⠲⡀⡀⠈⡀⠸⢟⠞⠲⡀⢛⠈⠎⠌⠓⠴⠃⠹⡀⠈⣤⠚⠥⣄⠦⠉⢤⢦⠖⠏⠇⠏⡝⣠⠋⡀⠑⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢠⡄⣿⢿⠁⣿⡠⠓⠿⠪⠝⠣⠊⠅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⣝⡱⢜⢑⢕⡀⡀⡀⡀⡆⡄⢻⢰⢲⢱⢹⢩⠶⣴⢻⢰⢰⢰⢁⡀⡀⢤⣤⡮⡏⡮⡮⡞⡇⡶⡆⡎⡹⣥⡇⡇⣞⡆⡧⢠⢠⡀⡍⡏⡤⠤⠍⠃⠤⠍⠉⢼⣽⣵⢹⢹⢹⢸⣼⡧⡀⡆⡆⡆⡤⠆⣞⣾⣷⢸⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⣿⣺⢧⢎⢕⠈⢂⠂⢃⢁⢊⠸⡼⠶⡼⠛⡼⠮⣘⠸⡼⠶⡼⡗⠚⣤⢳⠏⣲⢧⠓⢻⣇⢧⡗⢦⢿⠚⣶⢧⢧⡧⠃⣹⣽⣼⠚⠙⢧⠛⠙⣧⢠⡛⣤⣤⠱⢽⡟⠒⣸⡒⠹⣿⣿⣬⣳⢃⣇⣧⣇⠧⢻⡟⢸⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀
// ⠚⣿⣿⣸⡵⠓⢳⡀⠃⣣⡃⠄⡀⢃⡀⡀⡀⣀⠓⡀⡀⡀⡀⠇⠠⢰⡀⡾⢠⠟⡀⡌⠙⣧⠱⢹⡀⡇⢧⢰⠐⡀⢀⠃⡏⡀⡀⠐⢘⡓⠟⡀⡀⡀⡀⡀⠁⠹⣿⣀⣿⣆⣿⣿⣿⣎⣿⣽⣿⣿⡿⣾⠲⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢠
// ⡀⠘⣿⡟⣶⣴⣁⠵⠋⠁⠞⡊⢋⠐⣤⠚⢁⡆⡀⡀⠄⡀⡀⡀⠑⡙⢰⠳⢋⠠⡀⠣⡼⢸⡀⢸⡃⣿⡀⠈⡀⠈⡼⣾⡀⡀⠠⢔⣇⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢸⣾⣿⣿⣿⣿⣽⡿⣿⣿⣿⣿⠟⠠⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⠐⡀⢨
// ⡀⣻⣭⣽⢯⣿⣵⢙⣉⡴⠁⡼⣡⣯⠘⠈⣘⢈⣀⣤⠒⢀⠄⡀⠠⡀⢸⠈⠁⡆⣾⢀⢃⡟⡜⣼⡀⡇⡀⡀⡀⠰⢀⠇⡀⠁⠰⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⠙⣿⣿⣿⡗⣿⡇⣿⣿⣿⠋⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡀⡉⣠⠁
// ⠈⢭⣿⣾⡟⣾⣼⢣⠛⣷⣫⠟⡀⢰⠳⣠⠶⢁⡀⡆⡗⠚⠤⠌⠉⡀⠈⢣⢻⣌⣀⡴⠋⠜⣰⠧⣼⡀⡀⡀⡀⠿⣾⡀⡀⡀⠘⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡄⡀⣿⣿⣿⡱⣿⢽⣿⣿⠁⡀⡀⡀⡀⠠⡀⡀⡄⡀⠐⡀⡀⢁⢀⠠⢽
// ⡀⡀⡀⣿⣷⣟⣯⣿⣿⣵⣡⠿⠙⢴⠶⠗⠛⡴⠳⠖⠒⡀⡀⡀⡀⡀⡀⡀⠁⡑⠂⣐⢡⣾⠉⣰⠃⡀⡀⡀⡀⠃⡏⡀⡀⢌⢵⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡀⠂⡥⣿⣿⣿⣗⣿⣾⣿⡠⠅⠄⠠⡀⠈⠐⠈⡀⡴⠊⠉⡀⡀⠁⢠⠂⠟
// ⡀⡀⡀⡀⠛⣿⣽⣿⣿⣅⣟⣩⠾⢻⡠⣓⣀⠷⠴⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⢵⠋⢠⣵⠃⢐⡀⡀⡀⢰⠲⠂⡀⠐⢂⢥⠵⢁⡀⠠⡀⢀⢀⠔⡀⢀⡀⠬⡀⣿⣿⣿⣇⣿⣿⡟⣠⠚⠉⠭⠉⣄⢀⠈⡄⡜⡀⡀⠊⡤⡉⢇⣄⠼⣉
// ⡀⡀⡀⠁⡀⠠⣿⣿⣿⣿⣿⣿⣙⠡⢁⡎⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠉⠛⠠⠢⠂⠄⠈⢐⣫⣹⡀⡁⡀⡱⣯⠟⢧⣶⣀⠁⡜⣠⣦⣉⣠⡇⠾⢲⣿⣿⣿⣾⣿⡟⠁⡀⡠⠠⠤⠦⣈⡀⡀⡀⠣⡀⡀⡍⡀⡞⢨⡀⣠⠋
// ⡀⡀⠂⡀⡀⡀⠟⣿⣿⣿⣿⣏⣹⣿⡻⡃⡡⡐⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⢑⡑⠨⠢⠅⡗⣾⢀⠄⢠⣌⣩⣿⣦⣴⣧⠃⠿⠋⡉⣧⣩⣹⣶⣿⣿⣿⡿⣿⢿⠠⠔⠄⠈⠔⠐⠐⠒⡀⠈⠒⠂⣀⠑⠈⠓⠲⠋⡀⡇⡴
// ⢠⢐⡅⢀⠠⠂⢌⠿⣿⣿⣿⣿⣿⣿⣞⡪⢱⢕⡈⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⠢⢅⡉⣿⡪⢢⣜⡣⡏⡀⡀⡀⡀⡀⡀⡀⠈⠉⠉⢿⣿⣿⣿⣿⣿⡿⠐⡈⠄⠰⡀⣀⠂⢀⡀⠄⢀⡀⡀⡀⣌⠘⠚⠖⢁⡀⢟⡡
// ⡖⢹⡀⠱⣐⣣⣊⣼⣯⣿⣿⣿⣿⣿⣯⢪⢕⡎⠡⠌⠈⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠘⠂⣿⡕⢪⡽⠟⡀⡀⠂⡀⡀⡀⡀⡀⡀⣀⡐⢤⣿⣿⣿⣿⢟⠔⠆⡀⡀⣀⠆⠐⡀⠃⡀⡀⢀⠒⠤⣀⡀⢁⠘⠘⠘⡈⣶⣀
// ⣦⢪⣕⠿⠋⠙⡀⡀⠈⠭⢿⣽⣿⣿⣿⢯⣗⡺⢇⡂⢐⢅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠉⠹⣪⣞⡂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢐⠈⣽⣿⣿⡯⠁⡀⠁⠄⡀⡀⡀⠠⠁⡀⡀⣄⡀⠢⢳⠈⡉⣦⠙⡘⡙⢈⣈⠛
// ⣿⡾⠓⡀⡀⡀⡀⡀⡀⡀⢔⢨⠻⣿⣿⣿⣯⣺⡧⢌⡨⠕⢂⡠⠂⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠚⢆⠡⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡵⠅⣿⡟⢀⣤⠖⠛⠉⠉⠉⠉⠙⠓⠶⣄⡀⠈⠓⢥⠓⠘⡤⢳⠑⣣⠹⠈⡆
// ⣿⡀⡀⡀⡀⡀⡀⡀⡀⡀⠠⢰⢳⠘⣿⣿⣿⣿⣽⣗⡪⢕⡨⢑⠠⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠂⡀⡀⡀⡀⠐⠠⡀⠕⢠⡆⣸⣿⣴⠋⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠓⣄⠲⣈⢶⠙⡄⣷⠈⣧⢳⠹
// ⡧⢀⡀⡀⡀⡀⡀⡀⡀⡀⠂⡀⢳⢻⡀⣿⣿⣿⣿⣿⣝⡹⢕⠣⠢⠢⠅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠄⠠⠨⠨⠘⢖⢢⡹⢻⡿⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢄⡀⠉⢦⠳⡁⢶⠈⣇⢆⣆⢿
// ⡋⡀⢂⡀⠠⡀⡀⠈⠄⠠⡜⡅⠔⢱⣿⡄⢻⣿⣿⣿⣞⡷⡺⡳⡑⡂⠌⠠⠠⡁⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠂⢔⡢⢱⡮⣳⡾⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠘⣆⡀⠙⣌⣦⠳⣛⣇⣧⢦
// ⡪⢅⠂⠅⡀⠈⠂⠐⡑⢀⡁⢾⣼⢥⣻⣿⣆⠹⣿⣿⣿⣿⣻⢗⣪⡕⢊⡌⡡⢄⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠈⠳⡰⡿⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⢿⡀⠈⣦⢷⢪⣾⡌⣧
// ⢑⡤⢱⢄⡺⢏⢀⢾⢸⣷⣾⣿⣿⠱⢯⣿⣿⣠⠙⣿⣿⣿⣷⣿⣳⢼⢇⡨⢅⢅⢐⠅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⠅⡂⡂⢿⣄⡀⢷⢻⡻⣿⡉
// ⡀⡲⠮⢑⣂⣬⣹⣯⣾⣿⣷⣿⣷⣿⣿⣿⣿⣤⣿⡄⢿⣿⣿⣿⣿⣹⡵⢮⡕⠪⢑⡂⠨⠅⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡀⠠⠄⠨⢕⢻⣆⠢⣷⢻⡽⣿
// ⡀⡀⡃⠄⣧⡾⠁⡀⡀⡀⠄⠚⡿⣿⣿⣿⣿⡴⣾⣿⡄⢿⣿⣿⣿⣽⣳⣗⢎⡜⡘⢊⠣⠐⡐⢄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠐⡂⡐⢆⡌⢸⡇⢝⣿⡄⡧⢿⢻⣻
// ⡀⠐⠢⡜⡀⡀⡀⡀⡀⡀⠰⡐⢀⡧⡿⣿⣿⣶⢾⣿⣿⣆⠻⣿⣿⣿⣿⣗⣽⢯⡹⢇⡨⢅⢢⢜⡂⢐⢀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⢀⡀⡀⢔⡑⡊⢱⡎⢕⡮⣿⣿⡈⣎⣷⢿
// ⡀⡀⠓⡀⡀⡀⡀⡀⡀⡀⡀⢨⠁⡖⢡⣿⣿⣷⠛⣿⢿⣿⣧⠘⣿⣿⣿⣿⣿⣽⣞⢷⡪⢸⢧⡎⢅⡌⢂⠠⢄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡐⢂⡊⢌⡌⢱⣎⡼⡳⣿⣿⣿⣿⢿⡌⣷
// ⡀⡀⡊⢈⡀⡀⡀⡀⡀⡀⠄⠄⢰⡢⢎⣽⣿⣿⠛⣿⣻⣻⣿⣷⢌⢿⣿⣿⣿⣿⡿⢯⣝⣝⡣⢎⡡⢔⢪⢕⠪⠅⡈⠂⡀⡀⢀⡀⠠⡀⠄⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⡀⠄⠌⠡⢊⡌⢱⡎⢕⢯⣿⣝⣽⣿⣿⣿⣧⣿⡜
// ⡀⡀⠨⡂⠄⡀⠠⡀⠑⠐⡅⠌⢍⡃⣸⣿⣿⣿⣡⠶⣿⣿⣿⢿⣿⡥⠻⣿⣿⣿⣷⣿⣞⣯⣪⢭⡎⡸⢇⡔⢌⡢⢌⡐⢂⠄⡀⠂⡀⡀⡀⡀⡀⢀⡀⢀⡀⠄⡀⠈⡀⡀⡀⡀⢀⡈⢀⠄⢐⢔⢜⢎⡎⣎⣳⣳⣺⣽⣿⣿⣿⣿⣿⣿⡼⣾
// ⡀⡀⡢⠈⠌⢁⡤⢆⠔⠪⢠⣆⢸⣧⣛⣢⣿⣿⣤⠞⢿⢾⣿⣿⢿⢿⣶⠙⣿⣿⣿⣿⣿⣯⣯⡽⡷⢧⢵⣇⡸⢕⢌⡨⢅⡨⠨⠅⢀⡀⢀⠈⠐⠄⠠⠄⠠⠂⠐⡐⡀⠠⠄⠠⡀⢐⢌⢂⢢⡇⢪⡕⡪⢵⣻⣯⣿⣿⣿⣿⣿⣿⣿⢿⣿⢿

// --------------------------------------------------------------------------------------------------------------------------------------//
/*
  JAI SARASWATI MAA
*/
// --------------------------------------------------------------------------------------------------------------------------------------//

#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#pragma GCC optimize("O3,unroll-loops")

using namespace std;
using namespace chrono;
using namespace __gnu_pbds;

typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; // find_by_order, order_of_key
template <typename T>
#define ordered_mset tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update>
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x <<" "; _print(x); cerr << "\n";
#else
#define debug(x)
#endif
// --------------------------------------------------------------------------------------------------------------------------------------//
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define db double
#define ch char
#define ll long long
#define ull unsigned long long
#define uint unsigned int
#define lld long double
#define pb push_back
#define eb emplace_back
#define str string
#define srt(v) sort(v.begin(), v.end())
#define srtd(v) sort(v.rbegin(), v.rend())
#define ff(i,a,b)    for(ll i = a;i<b;i++)
#define ffc(i,a,b,c)  for(ll i = a;i<b;i+=c)
#define fb(i,a,b)   for(ll i=a;i>=b;i--)
#define fbc(i,a,b,c) for(ll i=a;i>=b;i-=c)
#define vi  vector<ll>
#define vdb vector<db>
#define vch vector<ch>
#define vs vector<str>
#define pii pair<ll,ll>
#define vpi vector<pair<ll,ll>>
#define vvi vector<vector<ll>>
#define inn   ll n;cin>>n;
#define in(a) ff(i,0,a.size()) cin>>a[i];
#define outs(v)  ff(i,0,v.size()) cout<<v[i]<<' ';
#define outl(v)  ff(i,0,v.size()) cout<<v[i]<<"\n";
#define all(x)  x.begin(),x.end()
#define mp map<ll,ll>
#define mpch map<char,ll>
#define mst multiset<int>
#define ump unordered_map<ll,ll>
#define be begin()
#define cl clear()
#define en end()
#define si size()
#define bck back()
#define pbck pop_back()
#define br break;
#define cont continue;
#define ret return;
#define lb lower_bound
#define ub upper_bound
#define pq priority_queue
#define show(c) cout<<c;
#define spc show(" ")
#define fi first
#define ss second
#define len length()
#define set_bits __builtin_popcountll
#define nl cout<<"\n";
#define yes cout<<"YES"<<"\n";
#define no cout<<"NO"<<"\n";
#define imp cout<<"IMPOSSIBLE"<<endl;
#define st set<ll>
#define hey debug("hey")
#define llmax LLONG_MAX
#define llmin LLONG_MIN
#define intmax INT_MAX
#define intmin INT_MIN
#define stk stack<ll>
#define dq deque<ll>
#define lst list<ll>
#define po pop()
#define pf pop_front()
#define maxvec *max_element
#define minvec *min_element
#define vvvi vector<vvi>  
#define Random_Generator(name) mt19937 name(chrono::steady_clock::now().time_since_epoch().count());
ll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b);}
ll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b);}
const ll MOD = 1e9+7;
const ll mod=998244353;
const ll pmax=1e5+10;
const double pi = 3.141597653;
// --------------------------------------------------------------------------------------------------------------------------------------//
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
// --------------------------------------------------------------------------------------------------------------------------------------//
template<typename T>T minn(const vector<T>&v){return *min_element(v.begin(),v.end());}
template<typename T>T maxx(const vector<T>&v){return *max_element(v.begin(),v.end());}
template<typename T>T summ(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};
template<typename T>T rev(const T &v){return T(v.rbegin(),v.rend());};
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.fi); cerr << ","; _print(p.ss); cerr << "}";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {cerr<<"{";_print(i.fi);cerr<<" ";_print(i.ss);cerr<<"}";cerr << " ";} cerr << "]";}
// --------------------------------------------------------------------------------------------------------------------------------------//
ll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}
ll lcm(ll a, ll b) {return (a / gcd(a, b)) * b;}
ll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m
ll vec_sum(vi v){ll sum=0;ff(i,0,v.si){sum=sum+v[i];}return sum;}
ll mex_of_vec(vi v){srt(v);ll prev=v[0];ll mex=-1;if(prev!=0){return 0;}ff(i,1,v.si){if(v[i]-prev>1){mex=prev+1;break;}prev=v[i];}return mex==-1?prev+1:mex;}
db dis(pii a, pii b) {return sqrt(pow((a.first - b.first), 2) + pow((a.second - b.second), 2));}
ll digit_sum(int n) {ll res = 0;while(n) {res += n % 10;n /= 10;}return res;}
mp primeFactorization(ll n) {mp prime_factors;while (n % 2 == 0) {prime_factors[2]++;n /= 2;}for (int i = 3; i * i <= n; i += 2) {while (n % i == 0) {prime_factors[i]++;n /= i;}}if (n > 2) {prime_factors[n]++;}return prime_factors;}
void fib(ll n, ll &a, ll &b) {if (n == 0) {a = 0;b = 1;return;}ll a1, b1;fib(n >> 1, a1, b1);ll c = a1 * ((b1 << 1) - a1);ll d = a1 * a1 + b1 * b1;if (n & 1) {a = d;b = c + d;} else {a = c;b = d;}}
ll getfib(ll n) {ll a, b;fib(n, a, b);return a;}
ll bin_mul(ll a,ll b){ll ans=0;while(b){if(b&1) ans=mod_add(ans,a,MOD);a=mod_add(a,a,MOD);b>>=1;}return ans;}
db log_base(db a, db b) {return log(a) / log(b);}
bool powerof2(ll x){if(x==0) return false;else if(x&(x-1)==0) return true;else return false;}
ll gcd_dio(ll a, ll b, ll &x, ll &y){if (b == 0){x = 1;y = 0;return a;}ll x1, y1;ll d = gcd_dio(b, a % b, x1, y1);x = y1;y = x1 - y1 * (a / b);return d;} 
ll inverse(ll a, ll m){ll x, y;ll g = gcd_dio(a, m, x, y);if (g != 1){return -1;}else{x = (x % m + m) % m;return x;}}
ll modInverse(ll a, ll m) {int m0 = m, t, q;int x0 = 0, x1 = 1;if (m == 1)return 0;while (a > 1) {q = a / m;t = m;m = a % m, a = t;t=x0;x0 = x1 - q * x0;x1 = t;} if (x1 < 0)x1 += m0;return x1;}
ll combination(ll n, ll r, ll m, vi& fact) {ll val1 = fact[n]; ll val2 = mminvprime(fact[r], m); ll val3 = mminvprime(fact[n - r], m); return ((val1 * val2) % m * val3) % m;}
ll pwr(ll a, ll b, ll mod = 0){ll result = 1;if(mod == 0){while(b){if(b & 1) result *= a;a *= a;b = b >> 1;}}else {while(b){if(b & 1){result *= a;result  = result % mod;}a *= a;a = a % mod;b = b >> 1;}}return result;}
vi segTree;
//build the segment tree
void build(vi&a,ll start,ll end,ll index){
  if(start==end){  
    segTree[index]=a[start];
    return; 
  }
  ll mid=(start+end)/2;
  ll left=2*index;ll right=2*index+1;
  build(a,start,mid,left);
  build(a,mid+1,end,right);
  segTree[index]=max(segTree[left],segTree[right]);
}
//update at a given point in the segment tree
void update(vi&arr,ll start,ll end,ll index,ll pos,ll val){
  if(start==end){
    arr[pos]=(val);
    segTree[index]=arr[pos];
    return;
  }
  ll mid=(start+end)/2;
  if(pos>=start && pos<=mid){
    update(arr,start,mid,2*index,pos,val);
  }else{
    update(arr,mid+1,end,2*index+1,pos,val);
  }
  segTree[index]=(segTree[2*index]+segTree[2*index+1]);
}
//range query the array
ll query(ll start,ll end,ll index,ll l,ll r){
  //complete overlap
  if(start>=l && r>=end){ 
    return segTree[index];
  }
  // no overlap
  if(l>end || start>r){ 
    return llmin;
  }
  ll mid=(start+end)/2;
  ll leftans=query(start,mid,2*index,l,r);
  ll rightans=query(mid+1,end,2*index+1,l,r);
  return max(leftans,rightans);
}
// struct DSU_new{
//   int n;
//   vi p;
//   DSU_new(int _n){
//     n = _n;
//     p.assign(2 * n,0);
//     for (int i = 0;i<=2 * n - 1;i++)p[i] = i;
//   }
//   int Find(int i){
//     if (p[i] == i)return p[i];
//     return p[i] = Find(p[i]);
//   }
//   bool areFriends(int u,int v){
//     return Find(u) == Find(v);
//   }
//   bool areEnemies(int u,int v){
//     return Find(u) == Find(n + v) || Find(u + n) == Find(v);
//   }
//   void MergeFriends(int u,int v){
//     int fu = Find(u),fv = Find(v),eu = Find(u + n),ev = Find(v + n);
//     p[fv] = fu;
//     p[ev] = eu;
//   }
//   void MergeEnemies(int u,int v){
//     int fu = Find(u),fv = Find(v),eu = Find(u + n),ev = Find(v + n);
//     p[fv] = eu;
//     p[ev] = fu;
//   }  
// };

// template <class T>
// class DisjointSetDS{
//   unordered_map<T,T>parent;
//   unordered_map<T,ll>SetSpecs;
// public:
//   void makeset(T e){
//     parent[e]=e;
//     SetSpecs[e]=1;
//   }
//   void Union(T e1,T e2){
//     e1=find(e1);e2=find(e2);
//     if(e1==e2) return;
//     ll size1=SetSpecs[e1];
//     ll size2=SetSpecs[e2];
//     if(size1<size2){
//       swap(e1,e2);
//     }
//     parent[e2]=e1;
//     SetSpecs[e1]+=SetSpecs[e2];
//     auto it=SetSpecs.find(e2);
//     SetSpecs.erase(it);
//   }
//   T find(T e){
//     if(parent[e]==e) return e;
//     return parent[e]=find(parent[e]);
//   }
//   ll sizeofset(T e){
//     T p=find(e);
//     return SetSpecs[p];
//   }
// };
// ll kthparent(ll k,ll node,vvi&up){
//   ll x=node;
//   fb(i,19,0){
//     if(k&(1<<i)) x=up[x][i];
//   }
//   return x;
// }
// ll lca(ll x,ll y,vi&depth,vvi&up){
//   if(depth[x]<depth[y]) swap(x,y);
//   fb(i,19,0){
//     if(depth[x]-depth[y]>=(1<<i)){
//       x=up[x][i];
//     }
//   }
//   if(x==y){
//     return x;
//   }
//   fb(i,19,0){
//     if(up[x][i]!=up[y][i]){
//       x=up[x][i];
//       y=up[y][i];
//     }
//   }
//   return up[x][0];
// }
// --------------------------------------------------------------------------------------------------------------------------------------//
void solve(){
  ll n,s,x;cin>>n>>s>>x;
  vi a(n);in(a);map<ll,vi>mp1;ll cursum=0;ll curmaxi=llmin;
  segTree.resize(4*n);
  build(a,0,n-1,1);
  ll fans=0;
  for(int i=0;i<n;i++){
    ll el=a[i];cursum+=el;curmaxi=max(curmaxi,el);
    if(cursum==s && curmaxi==x) fans++;
    ll req=cursum-s;
    debug(req)
    if(mp1.count(req)){
      vi temp=mp1[req];
      debug(temp)
      ll lo=0;ll hi=temp.size()-1;ll ans=-1;
      while(lo<=hi){
        ll mid=(lo+hi)/2;
        ll some=query(0,n-1,1,temp[mid],i);
        if(some==x){
          ans=mid;
          hi=mid-1;
        }else if(some>x){
          lo=mid+1;
        }else{
          hi=mid-1;
        }
      }
      debug(ans)
      lo=0;hi=temp.size()-1;ll ans2=-1;
      while(lo<=hi){
        ll mid=(lo+hi)/2;
        ll some=query(0,n-1,1,temp[mid],i);
        debug(some)
        if(some==x){
          ans2=mid;
          lo=mid+1;
        }else if(some>x){
          lo=mid+1;
        }else{
          hi=mid-1;
        }
      }
      debug(ans2)
      if(ans!=-1){
        fans+=(ans2-ans+1);
      }
    }
    debug(fans)
    mp1[cursum].pb(i+1);
    debug(mp1)
  }
  show(fans) nl ret
}
// --------------------------------------------------------------------------------------------------------------------------------------// 
int main() {
#ifndef ONLINE_JUDGE
  freopen("input.txt","r",stdin);
  freopen("output.txt","w",stdout);
	freopen("Error.txt", "w", stderr);    
#endif
ll t=1;
cin>>t;
debug(t)
for(int i=1;i<=t;i++){
  solve();
}
return 0;
}
// --------------------------------------------------------------------------------------------------------------------------------------//